<!DOCTYPE html>
<html>

<head>

<meta charset="utf-8">
<title>Notas del Curso</title>


<style type="text/css">
body {
  font-family: Helvetica, arial, sans-serif;
  font-size: 14px;
  line-height: 1.6;
  padding-top: 10px;
  padding-bottom: 10px;
  background-color: white;
  padding: 30px; }

body > *:first-child {
  margin-top: 0 !important; }
body > *:last-child {
  margin-bottom: 0 !important; }

a {
  color: #4183C4; }
a.absent {
  color: #cc0000; }
a.anchor {
  display: block;
  padding-left: 30px;
  margin-left: -30px;
  cursor: pointer;
  position: absolute;
  top: 0;
  left: 0;
  bottom: 0; }

h1, h2, h3, h4, h5, h6 {
  margin: 20px 0 10px;
  padding: 0;
  font-weight: bold;
  -webkit-font-smoothing: antialiased;
  cursor: text;
  position: relative; }

h1:hover a.anchor, h2:hover a.anchor, h3:hover a.anchor, h4:hover a.anchor, h5:hover a.anchor, h6:hover a.anchor {
  background: url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAA09pVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMy1jMDExIDY2LjE0NTY2MSwgMjAxMi8wMi8wNi0xNDo1NjoyNyAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNiAoMTMuMCAyMDEyMDMwNS5tLjQxNSAyMDEyLzAzLzA1OjIxOjAwOjAwKSAgKE1hY2ludG9zaCkiIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OUM2NjlDQjI4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OUM2NjlDQjM4ODBGMTFFMTg1ODlEODNERDJBRjUwQTQiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo5QzY2OUNCMDg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo5QzY2OUNCMTg4MEYxMUUxODU4OUQ4M0REMkFGNTBBNCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PsQhXeAAAABfSURBVHjaYvz//z8DJYCRUgMYQAbAMBQIAvEqkBQWXI6sHqwHiwG70TTBxGaiWwjCTGgOUgJiF1J8wMRAIUA34B4Q76HUBelAfJYSA0CuMIEaRP8wGIkGMA54bgQIMACAmkXJi0hKJQAAAABJRU5ErkJggg==) no-repeat 10px center;
  text-decoration: none; }

h1 tt, h1 code {
  font-size: inherit; }

h2 tt, h2 code {
  font-size: inherit; }

h3 tt, h3 code {
  font-size: inherit; }

h4 tt, h4 code {
  font-size: inherit; }

h5 tt, h5 code {
  font-size: inherit; }

h6 tt, h6 code {
  font-size: inherit; }

h1 {
  font-size: 28px;
  color: black; }

h2 {
  font-size: 24px;
  border-bottom: 1px solid #cccccc;
  color: black; }

h3 {
  font-size: 18px; }

h4 {
  font-size: 16px; }

h5 {
  font-size: 14px; }

h6 {
  color: #777777;
  font-size: 14px; }

p, blockquote, ul, ol, dl, li, table, pre {
  margin: 15px 0; }

hr {
  background: transparent url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x 0 0;
  border: 0 none;
  color: #cccccc;
  height: 4px;
  padding: 0;
}

body > h2:first-child {
  margin-top: 0;
  padding-top: 0; }
body > h1:first-child {
  margin-top: 0;
  padding-top: 0; }
  body > h1:first-child + h2 {
    margin-top: 0;
    padding-top: 0; }
body > h3:first-child, body > h4:first-child, body > h5:first-child, body > h6:first-child {
  margin-top: 0;
  padding-top: 0; }

a:first-child h1, a:first-child h2, a:first-child h3, a:first-child h4, a:first-child h5, a:first-child h6 {
  margin-top: 0;
  padding-top: 0; }

h1 p, h2 p, h3 p, h4 p, h5 p, h6 p {
  margin-top: 0; }

li p.first {
  display: inline-block; }
li {
  margin: 0; }
ul, ol {
  padding-left: 30px; }

ul :first-child, ol :first-child {
  margin-top: 0; }

dl {
  padding: 0; }
  dl dt {
    font-size: 14px;
    font-weight: bold;
    font-style: italic;
    padding: 0;
    margin: 15px 0 5px; }
    dl dt:first-child {
      padding: 0; }
    dl dt > :first-child {
      margin-top: 0; }
    dl dt > :last-child {
      margin-bottom: 0; }
  dl dd {
    margin: 0 0 15px;
    padding: 0 15px; }
    dl dd > :first-child {
      margin-top: 0; }
    dl dd > :last-child {
      margin-bottom: 0; }

blockquote {
  border-left: 4px solid #dddddd;
  padding: 0 15px;
  color: #777777; }
  blockquote > :first-child {
    margin-top: 0; }
  blockquote > :last-child {
    margin-bottom: 0; }

table {
  padding: 0;border-collapse: collapse; }
  table tr {
    border-top: 1px solid #cccccc;
    background-color: white;
    margin: 0;
    padding: 0; }
    table tr:nth-child(2n) {
      background-color: #f8f8f8; }
    table tr th {
      font-weight: bold;
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr td {
      border: 1px solid #cccccc;
      margin: 0;
      padding: 6px 13px; }
    table tr th :first-child, table tr td :first-child {
      margin-top: 0; }
    table tr th :last-child, table tr td :last-child {
      margin-bottom: 0; }

img {
  max-width: 100%; }

span.frame {
  display: block;
  overflow: hidden; }
  span.frame > span {
    border: 1px solid #dddddd;
    display: block;
    float: left;
    overflow: hidden;
    margin: 13px 0 0;
    padding: 7px;
    width: auto; }
  span.frame span img {
    display: block;
    float: left; }
  span.frame span span {
    clear: both;
    color: #333333;
    display: block;
    padding: 5px 0 0; }
span.align-center {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-center > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: center; }
  span.align-center span img {
    margin: 0 auto;
    text-align: center; }
span.align-right {
  display: block;
  overflow: hidden;
  clear: both; }
  span.align-right > span {
    display: block;
    overflow: hidden;
    margin: 13px 0 0;
    text-align: right; }
  span.align-right span img {
    margin: 0;
    text-align: right; }
span.float-left {
  display: block;
  margin-right: 13px;
  overflow: hidden;
  float: left; }
  span.float-left span {
    margin: 13px 0 0; }
span.float-right {
  display: block;
  margin-left: 13px;
  overflow: hidden;
  float: right; }
  span.float-right > span {
    display: block;
    overflow: hidden;
    margin: 13px auto 0;
    text-align: right; }

code, tt {
  margin: 0 2px;
  padding: 0 5px;
  white-space: nowrap;
  border: 1px solid #eaeaea;
  background-color: #f8f8f8;
  border-radius: 3px; }

pre code {
  margin: 0;
  padding: 0;
  white-space: pre;
  border: none;
  background: transparent; }

.highlight pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }

pre {
  background-color: #f8f8f8;
  border: 1px solid #cccccc;
  font-size: 13px;
  line-height: 19px;
  overflow: auto;
  padding: 6px 10px;
  border-radius: 3px; }
  pre code, pre tt {
    background-color: transparent;
    border: none; }

sup {
    font-size: 0.83em;
    vertical-align: super;
    line-height: 0;
}
* {
	-webkit-print-color-adjust: exact;
}
@media screen and (min-width: 914px) {
    body {
        width: 854px;
        margin:0 auto;
    }
}
@media print {
	table, pre {
		page-break-inside: avoid;
	}
	pre {
		word-wrap: break-word;
	}
}
</style>

<style type="text/css">
/**
 * prism.js default theme for JavaScript, CSS and HTML
 * Based on dabblet (http://dabblet.com)
 * @author Lea Verou
 */

code[class*="language-"],
pre[class*="language-"] {
	color: black;
	background: none;
	text-shadow: 0 1px white;
	font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
	text-align: left;
	white-space: pre;
	word-spacing: normal;
	word-break: normal;
	word-wrap: normal;
	line-height: 1.5;

	-moz-tab-size: 4;
	-o-tab-size: 4;
	tab-size: 4;

	-webkit-hyphens: none;
	-moz-hyphens: none;
	-ms-hyphens: none;
	hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
	text-shadow: none;
	background: #b3d4fc;
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
	text-shadow: none;
	background: #b3d4fc;
}

@media print {
	code[class*="language-"],
	pre[class*="language-"] {
		text-shadow: none;
	}
}

/* Code blocks */
pre[class*="language-"] {
	padding: 1em;
	margin: .5em 0;
	overflow: auto;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
	background: #f5f2f0;
}

/* Inline code */
:not(pre) > code[class*="language-"] {
	padding: .1em;
	border-radius: .3em;
	white-space: normal;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
	color: slategray;
}

.token.punctuation {
	color: #999;
}

.namespace {
	opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
	color: #905;
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.inserted {
	color: #690;
}

.token.operator,
.token.entity,
.token.url,
.language-css .token.string,
.style .token.string {
	color: #a67f59;
	background: hsla(0, 0%, 100%, .5);
}

.token.atrule,
.token.attr-value,
.token.keyword {
	color: #07a;
}

.token.function {
	color: #DD4A68;
}

.token.regex,
.token.important,
.token.variable {
	color: #e90;
}

.token.important,
.token.bold {
	font-weight: bold;
}
.token.italic {
	font-style: italic;
}

.token.entity {
	cursor: help;
}
</style>


</head>

<body>

<h1 id="toc_0">Notas del Curso de C</h1>

<p>Alan Badillo Salas</p>

<p>Email: badillo.soft@hotmail.com</p>

<p>Twitter: @badillosoft</p>

<p>Github: https://github.com/badillosoft/C</p>

<h2 id="toc_1">Introducción</h2>

<p><strong>C</strong> es un lenguaje de bajo-medio nivel tipado y compilado lo que significa que
es capaz de manipular la memoria del sistema operativo directamente entre otras
cosas y cada valor almacenado tiene un tipo de dato asociado que no se puede
cambiar. El que sea compilado significa que la computadora no puede entender
el código del programa y necesita de un compilador que traduzca el código fuente
a código máquina, este proceso se llama compilación.</p>

<p>El siguiente programa imprime en pantalla (salida estándar) <code>Hola mundo</code> y se
considera un programa completo en <em>C</em>.</p>

<blockquote>
<p><em>hola.c</em> - Imprime <code>Hola mundo</code> en la salida estándar </p>
</blockquote>

<div><pre><code class="language-c">#include &lt;stdio.h&gt;

int main(int argc, char *argv[]) {
    printf(&quot;Hola mundo&quot;);
    return 0;
}</code></pre></div>

<p>Para compilar el código debemos escribir en una terminal:</p>

<div><pre><code class="language-bash">$ gcc hola.c -o hola.bin</code></pre></div>

<p>Lo que hace <code>gcc</code> es traducir el archivo <code>hola.c</code> y crear un archivo ejecutable <code>hola.bin</code>.  </p>

<h1 id="toc_2">Parte I - Variables y Control de Flujo</h1>

<h2 id="toc_3">I.1 Variables</h2>

<p>Las variables son espacios donde podemos guardar valores. En <em>C</em> las variables
tienen asociado un tipo de dato. Los más comunes son:</p>

<ul>
<li>Número enteros: <strong>int</strong></li>
<li>Número decimal sencillo (flotante): <strong>float</strong></li>
<li>Número decimal doble: <strong>double</strong></li>
<li>Cáracter: <strong>char</strong></li>
</ul>

<p>La sintaxis es la siguiente:</p>

<p>Declaración sencilla: <code>tipo nombre;</code></p>

<p>Asignación: <code>nombre = valor;</code></p>

<p>Declaración compuesta: <code>tipo nombre = valor;</code></p>

<p>Declaración multiple: <code>tipo nombre1, nombre2 = valor2, nombre3, ...;</code></p>

<h2 id="toc_4">I.2 Control de flujo</h2>

<p>El flujo de un programa es la secuencia de instrucciones que
va siguiendo la computadora linea por linea, sin embargo, existen
estructuras que nos permiten cambiar el flujo de nuestro programa.</p>

<h3 id="toc_5">I.2.1 Condicionales</h3>

<p>Dentro de las estructuras condicionales encontramos <strong>if</strong> y <strong>switch</strong> estas
estructuras nos permitirán ejecutar un bloque de código cuando se cumpla
una condición.</p>

<blockquote>
<p>Estructura <em>if</em></p>
</blockquote>

<div><pre><code class="language-c">if (condición) {
    // Bloque a ejecutar si se cumple la condición
}</code></pre></div>

<p>En la estructura <em>if</em> podemos ejecutar un bloque si cierta condición no se cumple,
a esto se le conoce como el <strong>sino</strong> de la condición.</p>

<blockquote>
<p>Estructura <em>if-else</em></p>
</blockquote>

<div><pre><code class="language-c">if (condición) {
    // Bloque a ejecutar si se cumple la condición
} else {
    // Bloque a ejecutar SINO se cuample la condición
}</code></pre></div>

<p>Además de estas dos opciones las sentencias <em>if</em> pueden ser anidadas para controlar
un conjunto de varias condiciones.</p>

<blockquote>
<p>Estructura <em>if-else-if</em></p>
</blockquote>

<div><pre><code class="language-c">if (condición) {
    // Bloque a ejecutar si se cumple la condición
} else if (condición2) {
    // Bloque a ejecutar si se cumple la condición2
} else if (condición3) {
    // Bloque a ejecutar si se cumple la condición3
} else if (condiciónN) {
    // Bloque a ejecutar si se cumple la condiciónN
} else {
    // Bloque a ejecutar SINO se cuample ninguna condición anterior
}</code></pre></div>

<p>Existe una estructura más compacta para sustituir a <strong>if-else-if</strong> está estructura
es llamada selector de casos <strong>switch-case</strong>.</p>

<blockquote>
<p>Estructura <em>switch-case</em></p>
</blockquote>

<div><pre><code class="language-c">switch (variable) {
    case valor1:
        // Bloque a ejecutar si la variable tiene el valor 1
        break;
    case valor2:
        // Bloque a ejecutar si la variable tiene el valor 2
        break;
    case valorN:
        // Bloque a ejecutar si la variable tiene el valor N
        break;
    default:
        // Bloque a ejecutar SINO se cuample ninguna condición anterior
        break;
}</code></pre></div>

<h3 id="toc_6">I.2.2 Ciclos o Bucles</h3>

<p>Los ciclos o bucles es un flujo que se repite mediante una condición, existen dos estructuras
elementales para repetir un bloque de código. La estructura <strong>for</strong> nos permite repetir un bloque
utilizando una variable que cuente la iteración actual del ciclo, esta estructura es útil
para repetir ciclos de una forma determinada tantas veces.</p>

<p>La estructura <strong>while</strong> representa una repetición determinada por una condición, mientras
la condición se cumpla el ciclo se repetirá indeterminadamente, si no tenemos cuidado
podríamos hacer que nuestro programa se quede ejectundo cosas por siempre.</p>

<blockquote>
<p>Estructura <em>for</em></p>
</blockquote>

<div><pre><code class="language-c">int contador;
for (contador = 1; contador &lt;= 10; contador++) {
    printf(&quot;%d &quot;, contador);
}</code></pre></div>

<p>El código anterior imprime los números <code>1 2 3 4 5 6 7 8 9 10</code>. Como podemos
observar el <em>for</em> se divide en 3 procesos al declararse y son:</p>

<ol>
<li>Asignación del contador: Asignamos al contador a algún valor <code>contador = 1</code></li>
<li>Condición de paro: Definimos una condición para que el bloque se este repitiendo
mientras la condición se cumpla, en este caso la condición depende del contador <code>contador &lt;= 10</code></li>
<li>Incremento: Incrementamos o decrementamos el contador para que posea un nuevo valor para
el siguiente ciclo. En este caso lo estamos incrementando una unidad <code>contador++</code></li>
</ol>

<p>Los 3 procesos se separan por <code>;</code>.</p>

<blockquote>
<p>Estructura <em>while</em></p>
</blockquote>

<div><pre><code class="language-c">while (condición) {
    // Bloque a repetir mientras la condición se cumpla
}</code></pre></div>

<p>Una variación de la estructura <em>while</em> nos permitirá ejecutar el bloque al menos una vez
y luego preguntarse por la condición, a esta estructura se le conoce como <strong>do-while</strong>.</p>

<blockquote>
<p>Estructura <em>do-while</em></p>
</blockquote>

<div><pre><code class="language-c">do {
    // Bloque a repetir mientras la condición se cumpla
} while (condición);</code></pre></div>

<p>Observa que la condición ahora está abajo y finaliza en <code>;</code>.</p>

<h2 id="toc_7">I.3 Problemas</h2>

<p>A continuación se listarán algunos problemas y ejercicios en orden creciente
de dificultad.</p>

<h3 id="toc_8">Problema 1</h3>

<p>Crear una variable de tipo entero llamada <code>edad</code> que contenga el valor 18.</p>

<h3 id="toc_9">Problema 2</h3>

<p>El siguiente programa lee un número entero desde la entrada estándar (el teclado):</p>

<div><pre><code class="language-c">#include &lt;stdio.h&gt;

int main() {
    int a;
    
    printf(&quot;Dame un numero:&gt; &quot;);
    scanf(&quot;%d&quot;, &amp;a);
    
    return 0;
}</code></pre></div>

<p>Modificar el código anterior de la siguiente forma: Leer un entero desde la entrada
estándar y guardarlo en una variable llamada <code>edad</code>. Luego <em>si edad es mayor o igual a 18</em>
imprimir <code>Puede entrar al bar</code>, <em>sino</em> imprimir <code>No puede entrar al bar por ser menor de edad</code>.</p>

<h3 id="toc_10">Problema 3</h3>

<p>Mostrar en la pantalla el siguiente menú de opciones:</p>

<ol>
<li>Calcular la suma de dos números</li>
<li>Calcular la multiplicación de dos números</li>
<li>Calcular el mayor de dos números</li>
<li>Salir</li>
</ol>

<p>Después de mostrar el menú el programa deberá leer un entero desde la entrada estándar
y guardarlo en la variable <code>opcion</code>. Deberá repetir el programa indeterminadamente hasta que
la opción sea 4. Para romper un ciclo deberá escribir <code>break</code>, esto automáticamente sacará
del ciclo al programa.</p>

<p>Si la condición es menor a 0 o mayor a 4 deberá imprimir que la opción no es válida.</p>

<blockquote>
<p><strong>Hint</strong>: Utilizar un do-while para muestre el menú al menos una vez.</p>
</blockquote>

<h3 id="toc_11">Problema 4</h3>

<p>Extender el código del problema anterior para que cuando la opción sea 1, el programa
solicite dos números e imprima la suma de ellos. Similarmente programar las opciones 2 y 3
del menú.</p>

<p>Recuerde limpiar la pantalla con <code>system(&quot;cls&quot;);</code> en <em>windows</em> o <code>system(&quot;clear&quot;)</code> en <em>unix</em>.
También haga pausas de ser necesario con <code>getch();</code>.</p>

<h3 id="toc_12">Problema 5</h3>

<p>Se requiere un programa que cuente cuantos números multiplos de 2 o multiplos de 3 existen del
1 al 100. Para determinar si un número es multiplo de dos hacemos <code>n % 2 == 0</code> es decir que si
un número <em>n</em> es multiplo de 2 entonces su residuo a 2 será 0. Para determinar si un número
es multiplo de 3 es similar <code>n % 3 == 0</code>.</p>

<blockquote>
<p>Hint: Se necesita crear una variable que guarde la cuenta de los que cumplen ser multiplos
de 2 o multiplos de 3.</p>

<p>Hint: Para evaluar dos condiciones que se cumpla una u otra hacemos por ejemplo
<code>if (condición1 || condición2) { ... }</code>.</p>
</blockquote>

<h1 id="toc_13">Parte II - Arreglos, Punteros y Estructuras</h1>

<h2 id="toc_14">II.1 Arreglos</h2>

<p>Los arreglos son variables que permiten almacenar repetidamente valores de un mismo, accediendo a dichos
valores mediante un único nombre.</p>

<blockquote>
<p>Sintaxis <code>tipo nombre[tamaño];</code></p>
</blockquote>

<p>La sintaxis anterior se refiere a un arreglo de tamaño fijo lo que quiere decir que durante todo el programa
se reservará el espacio correspondiente para dicho arreglo.</p>

<p>Si queremos inicializar directamente el arreglo hacemos <code>tipo nombre[] = {valor0, valor1, ..., valorN}</code>, entonces
se creará el arreglo con el tamaño correspondiente y los valores dados.</p>

<p>Para acceder al valor del arreglo en un posición hacemos <code>valor = arraglo[indice];</code> donde el índice debe estar en
el rango válido desde 0 hasta el tamaño del arreglo menos 1.</p>

<p>Para calcular cuantos elementos se definieron en el arreglo hacemos <code>tamano = sizeof(arreglo) / sizeof(tipo);</code> es importante
dividir el valor entre el tamaño del tipo de dato. Esto hace que calcule los bytes reservados por el arreglo
entre los bytes que mide el tipo de dato.</p>

<p>Finalmente el siguiente código recorre el arreglo e imprime sus valores:</p>

<div><pre><code class="language-c">int i;
for (i = 0; i &lt; sizeof(arreglo) / sizeof(int); i++) {
    printf(&quot;%d &quot;, arreglo[i]);
}</code></pre></div>

<p>Lo mejor es guardar el tamaño del arreglo en una variable para no estarlo calculando a cada momento.</p>

<h2 id="toc_15">II.2 Punteros</h2>

<p>Un puntero es una variable que guarda la dirección de memoria de otra variable, esto significa que el valor
del puntero es una referencia en memoria a otra variable. La utilidad de los punteros reside en llamar a funciones
con paso de parámetros por referencia, crear estructuras con variables dinámicas y crear arreglos de tamaño dinámico.</p>

<p>Un puntero está asociado a un tipo de dato, por lo tanto no puede contener referencias a variables de otro tipo. El
puntero puede ser guardado a su vez en un doble puntero y así.</p>

<blockquote>
<p>Sintaxis: <code>tipo *nombre;</code></p>

<p>Declaración e inicialización: <code>tipo *nombre = &amp;variable;</code></p>
</blockquote>

<p>Observemos que los punteros son igualados a <code>&amp;variable</code>, esto significa en realidad que estamos accediendo a la dirección
de memoria de <code>variable</code>.</p>

<p>Podemos imprimir la dirección de memoria de una variable con <code>printf(&quot;%p&quot;, &amp;variable)</code> equivalente a <code>printf(&quot;%p&quot;, puntero)</code>.</p>

<p>Para recuperar el valor de la variable referida al puntero hacemos <code>valor = *puntero;</code> esto hará que el puntero acceda
al valor guardado en la dirección de memoria que tiene asociada <code>puntero</code>.</p>

<p>Si queremos modificar el valor de la dirección de memoria asociada al puntero hacemos <code>*puntero = nevo_valor;</code> esto hace
que el puntero cambie el valor en la dirección de memoria que tiene asociada <code>puntero</code>;</p>

<blockquote>
<p>Ejemplo: Asociar al puntero la variable que tiene el número mayor.</p>
</blockquote>

<div><pre><code class="language-c">int a = 2, b = 8;

int *p; // Declaramos un puntero sin variable asociada

if (a &gt; b) {
    p = &amp;a; // Asociamos la dirección de `a` porque es el mayor
} else {
    p = &amp;b; // Asociamos la dirección de `b` porque es el mayor
}

// Imprimimos el valor de la variable asociada a `p`, si `a` fuera mayor
// imprimiria el valor de `a`, si `b` fuera mayor imprimiria el valor de `b`  
printf(&quot;El numero mayor es %d&quot;, *p);</code></pre></div>

<h2 id="toc_16">II.3 Estructuras</h2>

<p>Las estructuras son tipos de datos compuestos por otros datos ya existentes (o la misma estructura). Esto permite
que el usuario pueda definir sus propios tipos de datos complejos.</p>

<blockquote>
<p>Sintaxis</p>
</blockquote>

<div><pre><code class="language-c">struct Nombre {
    tipo1 nombre1;
    tipo2 nombre2;
    ...
    tipoN nombreN;
};</code></pre></div>

<blockquote>
<p>Ejemplo: Contruimos una estructura llamada <code>Punto</code> la cual se compone de dos variables
de tipo entero <code>x</code> y <code>y</code>.</p>
</blockquote>

<div><pre><code class="language-c">struct Punto {
    int x;
    int y;
};</code></pre></div>

<p>Para usar la estructura debemos declarar variables del tipo de la estructura.</p>

<blockquote>
<p>Sintaxis <code>struct Estructura variable;</code></p>

<p>Ejemplo: Creamos dos variables <code>p</code> y <code>q</code> del tipo <code>struct Punto</code>.</p>
</blockquote>

<div><pre><code class="language-c">struct Punto {
    int x;
    int y;
};

int main()  {
    struct Punto p;
    struct Punto q;
    
    return 0;
}</code></pre></div>

<p>Para acceder a las variables dentro dentro de la estructura hacemos <code>estructura.variable = valor;</code> o
<code>valor = estructura.variable</code>;</p>

<blockquote>
<p>Ejemplo: Crear dos puntos <code>p</code> y <code>q</code>, asignarlos e imprimirlos.</p>
</blockquote>

<div><pre><code class="language-c">struct Punto p;
struct Punto q;

p.x = 10;
p.y = 20;

q.x = 2;
q.y = -8;

printf(&quot;P (%d, %d) &quot;, p.x, p.y);
printf(&quot;Q (%d, %d) &quot;, q.x, q.y);</code></pre></div>

<h2 id="toc_17">II.4 Aplicación de Estructuras y Punteros</h2>

<p>Una <em>pila</em> es una estructura de datos que nos permite ir acumulando variables, mejor dicho irlas apilando
como si se trataran de platos, la una <em>pila</em> de platos va encimando uno tras otro y para recuperar un plato
de abajo tenemos que desapilar los de arriba. Entonces cada plato tiene referencia al plato superior a el.
El primer plato colocado se conoce como la cabeza y el último como la cola. Nosotros debemos tener siempre
referencia a la cola.</p>

<p>El siguiente código muestra una pila que acumula valores de tipo entero:</p>

<div><pre><code class="language-c">struct Pila {
    int valor;
    struct Pila *siguiente;
};</code></pre></div>

<p>El código anterior es de sintaxis fácil, pero entenderlo es un poco más complejo. Para entenderlos cambiemos
el nombre de <code>Pila</code> por el de <code>Caja</code>:</p>

<div><pre><code class="language-c">struct Caja {
    int valor;
    struct Caja *siguiente;
};</code></pre></div>

<p>Ahora queda más claro que definimos una estructura llamada <code>Caja</code>, la cual contiene un valor entero y la referencia
a otra caja mediante un puntero de tipo <code>Caja</code> llamado <code>siguiente</code>. Entonces vamos a tener una secuencia de cajas
relacionadas mediante punteros.</p>

<p>El siguiente código define 3 cajas y las relaciona manualmente:</p>

<div><pre><code class="language-c">struct Caja c1; 
struct Caja c2; 
struct Caja c3;

c1.valor = 1;
c2.valor = 2;
c3.valor = 3;

c1.siguiente = &amp;c2;
c2.siguiente = &amp;c3;
c3.siguiente = NULL;</code></pre></div>

<p>Observemos que creamos tres cajas <code>c1</code>, <code>c2</code> y <code>c3</code>, luego les asignamos un valor a cada caja.</p>

<p>Si las variables fueran declaradas como punteros debemos tener cuidado de utilizar el operador <code>-&gt;</code>, de lo contrario en lugar de hacer <code>c1-&gt;valor</code>, su equivalente sería lo siguiente: <code>c1-&gt;siguiente</code> es equivalente a <code>(*c1).siguiente</code>.</p>

<p>Observamos que la caja <code>c3</code> no tiene ninguna caja siguiente, esto significa que nuestra pila queda más o menos
así: [c1]-&gt;[c2]-&gt;[c3].</p>

<p>¿Qué necesitamos hacer para insertar una nueva caja? El siguiente código crea una nueva caja y la asocia a c3.</p>

<div><pre><code class="language-c">struct Caja c4;

c4.valor = 4;
c4.siguiente = NULL;

c3.siguiente = &amp;c4;</code></pre></div>

<p>Observemos que ahora <code>c4</code> va a ser la caja sin caja <code>siguiente</code> y ahora la caja siguiente a <code>c3</code> es <code>c4</code>.</p>

<p>Los mismo sería para una caja <code>c5</code> pero ahora sustituyento <code>c3</code> por <code>c4</code>.</p>

<p>Entonces podemos generalizar este proceso llamado insertar caja. La siguiente función toma como primer
parámetro la última caja y como segundo parámetro el valor de la nueva caja a insertar y devuelve la
referencia a la nueva caja.</p>

<div><pre><code class="language-c">struct Caja* insertar_caja(Caja *ultimaCaja, int valor) {
    struct Caja *nueva_caja = (struct Caja*)malloc(sizeof(struct Caja));
    
    nueva_caja-&gt;valor = valor;
    nueva_caja-&gt;siguiente = NULL;
    
    ultima_caja-&gt;siguiente = nueva_caja;
    
    return nueva_caja;
}</code></pre></div>

<p>El siguiente código crea una caja y le inserta más cajas consecutivamente:</p>

<div><pre><code class="language-c">Caja cabeza;

cabeza = 1;

Caja *ultima_caja = &amp;cabeza;

ultima_caja = insertar_caja(ultima_caja, 2); // [1]-&gt;[2]-&gt;NULL

ultima_caja = insertar_caja(ultima_caja, 5); // [1]-&gt;[2]-&gt;[5]-&gt;NULL

ultima_caja = insertar_caja(ultima_caja, 8); // [1]-&gt;[2]-&gt;[5]-&gt;[8]-&gt;NULL

//...</code></pre></div>

<p>El siguiente código imprime la pila de cajas de manera similar a lo que está comentado.</p>

<div><pre><code class="language-c">void imprimir(struct Caja *c) {
    printf(&quot;[%d]-&gt;&quot;, c-&gt;valor);
    
    if (c-&gt;siguiente == NULL) {
        printf(&quot;NULL\n&quot;);
        return;
    }
    
    imprimir(c-&gt;siguiente);
}</code></pre></div>



<script type="text/javascript">
var _self="undefined"!=typeof window?window:"undefined"!=typeof WorkerGlobalScope&&self instanceof WorkerGlobalScope?self:{},Prism=function(){var e=/\blang(?:uage)?-(\w+)\b/i,t=0,n=_self.Prism={util:{encode:function(e){return e instanceof a?new a(e.type,n.util.encode(e.content),e.alias):"Array"===n.util.type(e)?e.map(n.util.encode):e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/\u00a0/g," ")},type:function(e){return Object.prototype.toString.call(e).match(/\[object (\w+)\]/)[1]},objId:function(e){return e.__id||Object.defineProperty(e,"__id",{value:++t}),e.__id},clone:function(e){var t=n.util.type(e);switch(t){case"Object":var a={};for(var r in e)e.hasOwnProperty(r)&&(a[r]=n.util.clone(e[r]));return a;case"Array":return e.map&&e.map(function(e){return n.util.clone(e)})}return e}},languages:{extend:function(e,t){var a=n.util.clone(n.languages[e]);for(var r in t)a[r]=t[r];return a},insertBefore:function(e,t,a,r){r=r||n.languages;var l=r[e];if(2==arguments.length){a=arguments[1];for(var i in a)a.hasOwnProperty(i)&&(l[i]=a[i]);return l}var o={};for(var s in l)if(l.hasOwnProperty(s)){if(s==t)for(var i in a)a.hasOwnProperty(i)&&(o[i]=a[i]);o[s]=l[s]}return n.languages.DFS(n.languages,function(t,n){n===r[e]&&t!=e&&(this[t]=o)}),r[e]=o},DFS:function(e,t,a,r){r=r||{};for(var l in e)e.hasOwnProperty(l)&&(t.call(e,l,e[l],a||l),"Object"!==n.util.type(e[l])||r[n.util.objId(e[l])]?"Array"!==n.util.type(e[l])||r[n.util.objId(e[l])]||(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,l,r)):(r[n.util.objId(e[l])]=!0,n.languages.DFS(e[l],t,null,r)))}},plugins:{},highlightAll:function(e,t){var a={callback:t,selector:'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'};n.hooks.run("before-highlightall",a);for(var r,l=a.elements||document.querySelectorAll(a.selector),i=0;r=l[i++];)n.highlightElement(r,e===!0,a.callback)},highlightElement:function(t,a,r){for(var l,i,o=t;o&&!e.test(o.className);)o=o.parentNode;o&&(l=(o.className.match(e)||[,""])[1],i=n.languages[l]),t.className=t.className.replace(e,"").replace(/\s+/g," ")+" language-"+l,o=t.parentNode,/pre/i.test(o.nodeName)&&(o.className=o.className.replace(e,"").replace(/\s+/g," ")+" language-"+l);var s=t.textContent,u={element:t,language:l,grammar:i,code:s};if(!s||!i)return n.hooks.run("complete",u),void 0;if(n.hooks.run("before-highlight",u),a&&_self.Worker){var c=new Worker(n.filename);c.onmessage=function(e){u.highlightedCode=e.data,n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(u.element),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},c.postMessage(JSON.stringify({language:u.language,code:u.code,immediateClose:!0}))}else u.highlightedCode=n.highlight(u.code,u.grammar,u.language),n.hooks.run("before-insert",u),u.element.innerHTML=u.highlightedCode,r&&r.call(t),n.hooks.run("after-highlight",u),n.hooks.run("complete",u)},highlight:function(e,t,r){var l=n.tokenize(e,t);return a.stringify(n.util.encode(l),r)},tokenize:function(e,t){var a=n.Token,r=[e],l=t.rest;if(l){for(var i in l)t[i]=l[i];delete t.rest}e:for(var i in t)if(t.hasOwnProperty(i)&&t[i]){var o=t[i];o="Array"===n.util.type(o)?o:[o];for(var s=0;s<o.length;++s){var u=o[s],c=u.inside,g=!!u.lookbehind,h=!!u.greedy,f=0,d=u.alias;u=u.pattern||u;for(var p=0;p<r.length;p++){var m=r[p];if(r.length>e.length)break e;if(!(m instanceof a)){u.lastIndex=0;var y=u.exec(m),v=1;if(!y&&h&&p!=r.length-1){var b=r[p+1].matchedStr||r[p+1],k=m+b;if(p<r.length-2&&(k+=r[p+2].matchedStr||r[p+2]),u.lastIndex=0,y=u.exec(k),!y)continue;var w=y.index+(g?y[1].length:0);if(w>=m.length)continue;var _=y.index+y[0].length,P=m.length+b.length;if(v=3,P>=_){if(r[p+1].greedy)continue;v=2,k=k.slice(0,P)}m=k}if(y){g&&(f=y[1].length);var w=y.index+f,y=y[0].slice(f),_=w+y.length,S=m.slice(0,w),O=m.slice(_),j=[p,v];S&&j.push(S);var A=new a(i,c?n.tokenize(y,c):y,d,y,h);j.push(A),O&&j.push(O),Array.prototype.splice.apply(r,j)}}}}}return r},hooks:{all:{},add:function(e,t){var a=n.hooks.all;a[e]=a[e]||[],a[e].push(t)},run:function(e,t){var a=n.hooks.all[e];if(a&&a.length)for(var r,l=0;r=a[l++];)r(t)}}},a=n.Token=function(e,t,n,a,r){this.type=e,this.content=t,this.alias=n,this.matchedStr=a||null,this.greedy=!!r};if(a.stringify=function(e,t,r){if("string"==typeof e)return e;if("Array"===n.util.type(e))return e.map(function(n){return a.stringify(n,t,e)}).join("");var l={type:e.type,content:a.stringify(e.content,t,r),tag:"span",classes:["token",e.type],attributes:{},language:t,parent:r};if("comment"==l.type&&(l.attributes.spellcheck="true"),e.alias){var i="Array"===n.util.type(e.alias)?e.alias:[e.alias];Array.prototype.push.apply(l.classes,i)}n.hooks.run("wrap",l);var o="";for(var s in l.attributes)o+=(o?" ":"")+s+'="'+(l.attributes[s]||"")+'"';return"<"+l.tag+' class="'+l.classes.join(" ")+'" '+o+">"+l.content+"</"+l.tag+">"},!_self.document)return _self.addEventListener?(_self.addEventListener("message",function(e){var t=JSON.parse(e.data),a=t.language,r=t.code,l=t.immediateClose;_self.postMessage(n.highlight(r,n.languages[a],a)),l&&_self.close()},!1),_self.Prism):_self.Prism;var r=document.currentScript||[].slice.call(document.getElementsByTagName("script")).pop();return r&&(n.filename=r.src,document.addEventListener&&!r.hasAttribute("data-manual")&&document.addEventListener("DOMContentLoaded",n.highlightAll)),_self.Prism}();"undefined"!=typeof module&&module.exports&&(module.exports=Prism),"undefined"!=typeof global&&(global.Prism=Prism);
</script>

<script type="text/javascript">
Prism.languages.clike={comment:[{pattern:/(^|[^\\])\/\*[\w\W]*?\*\//,lookbehind:!0},{pattern:/(^|[^\\:])\/\/.*/,lookbehind:!0}],string:{pattern:/(["'])(\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,greedy:!0},"class-name":{pattern:/((?:\b(?:class|interface|extends|implements|trait|instanceof|new)\s+)|(?:catch\s+\())[a-z0-9_\.\\]+/i,lookbehind:!0,inside:{punctuation:/(\.|\\)/}},keyword:/\b(if|else|while|do|for|return|in|instanceof|function|new|try|throw|catch|finally|null|break|continue)\b/,"boolean":/\b(true|false)\b/,"function":/[a-z0-9_]+(?=\()/i,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)\b/i,operator:/--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&?|\|\|?|\?|\*|\/|~|\^|%/,punctuation:/[{}[\];(),.:]/};
</script>

<script type="text/javascript">
Prism.languages.c=Prism.languages.extend("clike",{keyword:/\b(asm|typeof|inline|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|union|unsigned|void|volatile|while)\b/,operator:/\-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*\/]/,number:/\b-?(?:0x[\da-f]+|\d*\.?\d+(?:e[+-]?\d+)?)[ful]*\b/i}),Prism.languages.insertBefore("c","string",{macro:{pattern:/(^\s*)#\s*[a-z]+([^\r\n\\]|\\.|\\(?:\r\n?|\n))*/im,lookbehind:!0,alias:"property",inside:{string:{pattern:/(#\s*include\s*)(<.+?>|("|')(\\?.)+?\3)/,lookbehind:!0},directive:{pattern:/(#\s*)\b(define|elif|else|endif|error|ifdef|ifndef|if|import|include|line|pragma|undef|using)\b/,lookbehind:!0,alias:"keyword"}}},constant:/\b(__FILE__|__LINE__|__DATE__|__TIME__|__TIMESTAMP__|__func__|EOF|NULL|stdin|stdout|stderr)\b/}),delete Prism.languages.c["class-name"],delete Prism.languages.c["boolean"];
</script>

<script type="text/javascript">
!function(e){var t={variable:[{pattern:/\$?\(\([\w\W]+?\)\)/,inside:{variable:[{pattern:/(^\$\(\([\w\W]+)\)\)/,lookbehind:!0},/^\$\(\(/],number:/\b-?(?:0x[\dA-Fa-f]+|\d*\.?\d+(?:[Ee]-?\d+)?)\b/,operator:/--?|-=|\+\+?|\+=|!=?|~|\*\*?|\*=|\/=?|%=?|<<=?|>>=?|<=?|>=?|==?|&&?|&=|\^=?|\|\|?|\|=|\?|:/,punctuation:/\(\(?|\)\)?|,|;/}},{pattern:/\$\([^)]+\)|`[^`]+`/,inside:{variable:/^\$\(|^`|\)$|`$/}},/\$(?:[a-z0-9_#\?\*!@]+|\{[^}]+\})/i]};e.languages.bash={shebang:{pattern:/^#!\s*\/bin\/bash|^#!\s*\/bin\/sh/,alias:"important"},comment:{pattern:/(^|[^"{\\])#.*/,lookbehind:!0},string:[{pattern:/((?:^|[^<])<<\s*)(?:"|')?(\w+?)(?:"|')?\s*\r?\n(?:[\s\S])*?\r?\n\2/g,lookbehind:!0,inside:t},{pattern:/(["'])(?:\\\\|\\?[^\\])*?\1/g,inside:t}],variable:t.variable,"function":{pattern:/(^|\s|;|\||&)(?:alias|apropos|apt-get|aptitude|aspell|awk|basename|bash|bc|bg|builtin|bzip2|cal|cat|cd|cfdisk|chgrp|chmod|chown|chroot|chkconfig|cksum|clear|cmp|comm|command|cp|cron|crontab|csplit|cut|date|dc|dd|ddrescue|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|du|egrep|eject|enable|env|ethtool|eval|exec|expand|expect|export|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|getopts|git|grep|groupadd|groupdel|groupmod|groups|gzip|hash|head|help|hg|history|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|jobs|join|kill|killall|less|link|ln|locate|logname|logout|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|make|man|mkdir|mkfifo|mkisofs|mknod|more|most|mount|mtools|mtr|mv|mmv|nano|netstat|nice|nl|nohup|notify-send|nslookup|open|op|passwd|paste|pathchk|ping|pkill|popd|pr|printcap|printenv|printf|ps|pushd|pv|pwd|quota|quotacheck|quotactl|ram|rar|rcp|read|readarray|readonly|reboot|rename|renice|remsync|rev|rm|rmdir|rsync|screen|scp|sdiff|sed|seq|service|sftp|shift|shopt|shutdown|sleep|slocate|sort|source|split|ssh|stat|strace|su|sudo|sum|suspend|sync|tail|tar|tee|test|time|timeout|times|touch|top|traceroute|trap|tr|tsort|tty|type|ulimit|umask|umount|unalias|uname|unexpand|uniq|units|unrar|unshar|uptime|useradd|userdel|usermod|users|uuencode|uudecode|v|vdir|vi|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yes|zip)(?=$|\s|;|\||&)/,lookbehind:!0},keyword:{pattern:/(^|\s|;|\||&)(?:let|:|\.|if|then|else|elif|fi|for|break|continue|while|in|case|function|select|do|done|until|echo|exit|return|set|declare)(?=$|\s|;|\||&)/,lookbehind:!0},"boolean":{pattern:/(^|\s|;|\||&)(?:true|false)(?=$|\s|;|\||&)/,lookbehind:!0},operator:/&&?|\|\|?|==?|!=?|<<<?|>>|<=?|>=?|=~/,punctuation:/\$?\(\(?|\)\)?|\.\.|[{}[\];]/};var a=t.variable[1].inside;a["function"]=e.languages.bash["function"],a.keyword=e.languages.bash.keyword,a.boolean=e.languages.bash.boolean,a.operator=e.languages.bash.operator,a.punctuation=e.languages.bash.punctuation}(Prism);
</script>

<script type="text/x-mathjax-config">
if (typeof MathJaxListener !== 'undefined') {
  MathJax.Hub.Register.StartupHook('End', function () {
    MathJaxListener.invokeCallbackForKey_('End');
  });
}
</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>


</body>

</html>
